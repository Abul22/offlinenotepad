<!doctype html>
<html lang=en-US>

<head>
    <meta charset='utf-8'>
    <title>nenotes</title>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='description' content='nenotes, any notes for any time.'>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='canonical' href='https://nenotes.com/'>
    <link rel='manifest' href='/static/manifest.json'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <meta name='application-name' content='nenotes'>
    <meta name='apple-mobile-web-app-status-bar-style' content='black'>
    <meta name='apple-mobile-web-app-title' content='nenotes'>
    <link rel='icon' sizes='192x192' href='/static/images/touch/Airhorner_192.png'>
    <link rel='apple-touch-icon' href='/static/images/touch/Airhorner_192.png'>
    <meta name='msapplication-TileImage' content='/static/images/touch/Airhorner_144.png'>
    <meta name='msapplication-TileColor' content='#2196F3'>
    <meta name='theme-color' content='#2196F3'>
    <meta property='og:title' content='nenotes'>
    <meta property='og:type' content='website'>
    <meta property='og:image' content='https://airhorner.com/images/touch/Airhorner_192.png'>
    <meta property='og:url' content='https://nenotes.com/'>
    <meta property='og:description' content='nenotes, any notes for any time.'>
    <meta name='twitter:card' content='summary'>
    <meta name='twitter:url' content='https://nenotes.com/'>
    <meta name='twitter:title' content='nenotes'>
    <meta name='twitter:description' content='nenotes, any notes for any time.'>
    <meta name='twitter:image' content='https://airhorner.com/images/touch/Airhorner_192.png'>
    <meta name='twitter:creator' content='@yakczar'>
    <link rel='stylesheet' href='/static/css/style.css'>
    <!-- <script src='/static/js/pwacompat.min.js' async></script> -->
</head>

<body>
    <main id="app">
        <input type="file" id="selectFiles" value="Import" /> <button id="import">Import</button>
        <div class="checkmark" v-show="showCheck">‚úîÔ∏è</div>
        <div class="topbar" v-cloak>
            <span class="fl fonty">
                <a id='listlink' v-on:click="showList = true">üìö</a>&nbsp;
                <a id='newlink' v-on:click="makeNew">‚ö°</a>&nbsp;
                <span v-show="showEdit">
                    <a id='viewlink' v-on:click="showView = true">üëì</a>&nbsp;
                    <a id='deletelink' v-on:click="deleteDoc">üóëÔ∏è</a>
                </span>
                <a id='editlink' v-on:click="showEdit = true" v-show="showView">üìù</a>
            </span>
            <span class="fr fonty">
                <input id="searchbar" v-on:keyup="searchDocs" v-model="searchText" placeholder="search notes" style="width: 8em;">
                <a id="logoutlink" v-on:click="logOut">üö™</a>
            </span>
        </div>
        <div class="list" v-show="showSearch" v-cloak>
            <p>Found {{docsFound.length}} items that match '{{searchedText}}':</p>
            <div v-for="doc in docsFound">
                <div v-bind:id="doc.uuid" class="link" v-on:click="select($event)"><span v-if="doc.title">{{doc.title}}</span><span v-else>{{doc.uuid}}</span></div>
                <div>{{ formatDate(doc.created) }}</div>
                <q v-html="doc.snippet" class="snippet"></q>
            </div>
        </div>
        <div class="list" v-show="showList" v-cloak>
            <div v-for="doc in sortedDocs">
                <div v-bind:id="doc.uuid" class="link" v-on:click="select($event)"><span v-if="doc.title">{{doc.title}}</span><span v-else>{{doc.uuid}}</span></div>
                <div>{{ formatDate(doc.created) }}</div>
            </div>
        </div>
        <div class="fonty" v-show="showView" v-bind:class="{ iscode: isCode }" v-cloak>
            <h1 v-if="doc.title">{{doc.title}}</h1>
            <h1 v-else>{{doc.uuid}}</h1>
            <!-- TODO: if . in title, show raw pre-formated text -->
            <div v-html="doc.rawHTML"></div>
        </div>
        <input id="edittitle" v-show="showEdit" placeholder="Title" v-model="doc.title" v-on:keyup="updateDoc" v-bind:class="{ iscode: isCode }" v-cloak>
        <textarea class="writing" v-show="showEdit" id="editable" rows=110 placeholder="Click here and start writing" autofocus v-on:keyup="updateDoc" @keydown.tab.prevent="tabber($event)" v-model="doc.markdown" v-bind:class="{ iscode: isCode }" v-cloak>
            {{doc.markdown}}
                        <!-- TODO: if . in title, show raw pre-formated text -->
        </textarea>
        <img src="/static/images/background2.png" class="watermark" v-show="showListOrSearch">
    </main>
    <script src="/static/js/js.cookie.min.js"></script>
    <script src="/static/js/sweetalert.js"></script>
    <script src="/static/js/moment.min.js"></script>
    <script src="/static/js/vue.js"></script>
    <script src="/static/js/lz-string.js"></script>
    <script src="/static/js/pako.min.js"></script>
    <script src="/static/js/crypto-js.min.js"></script>
    <script src="/static/js/enc-utf16.min.js"></script>
    <script src="/static/js/lunr.min.js"></script>
    <script src="/static/js/localforage.js"></script>
    <script src="/static/js/showdown.min.js"></script>
    <!-- <script>
        /* code for the service worker */
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/static/sw.js', {
                    scope: '/'
                })
                .then(function (registration) {
                    console.log('Service Worker Registered');
                });
            navigator.serviceWorker.ready.then(function (registration) {
                console.log('Service Worker Ready');
            });
        }
    </script> -->
    <script>
    /* init */
    // initialize local storage
    localforage.setDriver([
        localforage.LOCALSTORAGE,
        localforage.WEBSQL,
        localforage.INDEXEDDB,
    ]).then(function() {
        console.log("[debug] initialized localforage");
    });

    /* 
    globals */
    var socket; // websocket
    var hasConnected = false;


    /* generic functions */
    // debounce function
    const debounce = function(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this,
                args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) {
                    func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait || 200);
            if (callNow) {
                func.apply(context, args);
            }
        };
    };

    // replace all
    String.prototype.replaceAll = function(search, replacement) {
        var target = this;
        return target.replace(new RegExp(search, 'g'), replacement);
    };

    function makeid() {
        const length = 8;
        var result = '';
        var characters = 'abcdefghijklmnopqrstuvwxyz0123456789';
        var charactersLength = characters.length;
        for (var i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    }


    // slugify the current text
    function slugify(text) {
        var lines = text.split('\n');
        for (var i = 0; i < lines.length; i++) {
            var slug = lines[i].toString().toLowerCase()
                .replace(/\s+/g, '-') // Replace spaces with -
                .replace(/[^\w\-]+/g, '') // Remove all non-word chars
                .replace(/\-\-+/g, '-') // Replace multiple - with single -
                .replace(/^-+/, '') // Trim - from start of text
                .replace(/-+$/, ''); // Trim - from end of text
            if (slug.length > 1) {
                return slug;
            }
        }
        return "";
    }

    // update the history
    function updateURL(url1, url2) {
        var newwindowname = slugify(url1);
        if (newwindowname == "") {
            newwindowname = url2;
        }
        // console.log(newwindowname);
        if (newwindowname != undefined && newwindowname.length > 0 && "/" + newwindowname !=
            window.location
            .pathname && newwindowname != window.location.pathname) {
            history.pushState({
                showView: app.showView,
                showEdit: app.showEdit,
                showList: app.showList,
                showSearch: app.showSearch,
            }, newwindowname, newwindowname);
            if (url1 == "/") {
                url1 = "nenotes"
            }
            document.title = url1;
        }
    }

    /* websockets */
    const socketMessageListener = (event) => {
        var data = JSON.parse(event.data);
        processSocketMessage(data);
    };
    const socketOpenListener = (event) => {
        console.log('[debug] connected');
        if (!hasConnected) {
            hasConnected = true;
            // request hashes for syncing down
            socketSend({
                "type": "hashes",
                "user": app.username,
            });
        }
    };
    const socketCloseListener = (event) => {
        if (socket) {
            console.log('[debug] disconnected');
            hasConnected = false;
        }
        var url = window.origin.replace("http", "ws") + '/ws';
        try {
            socket = new WebSocket(url);
            socket.addEventListener('open', socketOpenListener);
            socket.addEventListener('message', socketMessageListener);
            socket.addEventListener('close', socketCloseListener);
        } catch (err) {
            console.log("[debug] no connection available")
        }
    };



    /* vue apps */
    var app = new Vue({
        el: '#app',
        data: {
            username: "",
            password: "",
            docs: [],
            doc: {},
            sortedItems: [],
            docsFound: [],
            showView: false,
            showEdit: false,
            showList: false,
            showSearch: false,
            showCheck: false,
            searchText: "",
            searchedText: "",
            searchIndex: {},
            searchIndexLastModified: 0,
        },
        methods: {
            logOut: function() {
                console.log("logging out");
                Cookies.remove("app.username");
                Cookies.remove("app.password");
                this.username = "";
                this.password = "";
                this.docs = [];
                this.doc = {};
                this.docsFound = [];
                this.searchIndex = {};
            },
            searchDocs: debounce(function() {
                console.log(this.searchText.length);
                if (this.searchText.length == 0) {
                    return;
                }
                console.log(`[debug] conducting search for ${this.searchText}`)
                if (moment.utc() - this.searchIndexLastModified > 10000) {
                    console.log("[debug] indexing")
                    var documents = [];
                    for (i = 0; i < this.docs.length; i++) {
                        documents.push({ "id": i, "title": this.docs[i].title, "text": this.docs[i].markdown })
                    }
                    this.searchIndex = lunr(function() {
                        this.ref('id');
                        this.field('title');
                        this.field('text');
                        this.metadataWhitelist = ['position']

                        documents.forEach(function(doc) {
                            this.add(doc)
                        }, this)
                    })
                    this.searchIndexLastModified = moment.utc();
                }

                var _this = this;
                this.showSearch = true;
                this.searchedText = this.searchText;
                this.docsFound = [];
                console.log("[debug] searching")
                this.searchIndex.search(this.searchText).forEach(function(el) {
                    var doc = _this.docs[el.ref];
                    // extract snippets from search
                    var locations = [];
                    var wordFound = "";
                    for (var word in el.matchData.metadata) {
                        wordFound = word;
                        for (var pos in el.matchData.metadata[word].text.position) {
                            locations.push(el.matchData.metadata[word].text.position[pos][0]);
                        }
                    }
                    snippet = getSnippet(doc.markdown, wordFound, locations);
                    _this.docsFound.push({ title: doc.title, snippet: snippet, uuid: doc.uuid, modified: doc.modified, created: doc.created });
                })
            }, 500),
            flashCheck: function() {
                this.showCheck = true;
                var _this = this;
                setTimeout(function() {
                    _this.showCheck = false;
                }, 500)
            },
            tabber: function(event) {
                let text = this.doc.markdown,
                    originalSelectionStart = event.target.selectionStart,
                    textStart = text.slice(0, originalSelectionStart),
                    textEnd = text.slice(originalSelectionStart);

                this.doc.markdown = `${textStart}\t${textEnd}`
                event.target.value = this.doc.markdown
                event.target.selectionEnd = event.target.selectionStart = originalSelectionStart + 1

            },
            formatDate: function(datestr) {
                return moment(datestr).format("MM-DD hh:mm A")
            },
            removeDoc: function(index) {
                this.docs.splice(index, 1);
            },
            makeNew: function(e) {
                this.doc = new Document();
                this.showEdit = true;
            },
            select: function(event) {
                doc_uuid = event.currentTarget.id;
                for (i = 0; i < this.docs.length; i++) {
                    if (this.docs[i].uuid == doc_uuid) {
                        this.doc = this.docs[i];
                        this.showView = true;
                        break
                    }
                }
            },
            keyDown: function(e) {
                var keyCode = e.keyCode || e.which;

                if (keyCode == 9) {
                    e.preventDefault();
                    console.log(e.currentTarget);
                    var start = e.currentTarget.selectionStart;
                    var end = e.currentTarget.selectionEnd;
                    this.doc.markdown = [this.doc.markdown.slice(0, start), "\t", this.doc.markdown
                        .slice(start)
                    ].join('');
                    e.currentTarget.selectionStart = start;
                    e.currentTarget.selectionEnd = end;

                }
            },
            deleteDoc: function(e) {
                Swal.fire({
                    title: 'Are you sure?',
                    text: "You won't be able to revert this!",
                    type: 'warning',
                    showCancelButton: true,
                    confirmButtonColor: '#3085d6',
                    cancelButtonColor: '#d33',
                    confirmButtonText: 'Yes, delete it!'
                }).then((result) => {
                    if (result.value) {
                        console.log(`[debug] removing '${this.doc.uuid}'`)

                        var _this = this;
                        this.doc.rawHTML = "";
                        this.doc.markdown = "";
                        this.doc.title = "deleted";
                        this.doc.modified = moment.utc();
                        this.doc.hash = CryptoJS.SHA256(this.doc.uuid + this.doc.title + this.doc.markdown).toString()
                        var encoded = encode(JSON.stringify(this.doc), this.password);
                        socketSend({
                            "type": "update",
                            "user": this.username,
                            "uuid": this.doc.uuid,
                            "hash": this.doc.hash,
                            "data": encoded,
                        });

                        localforage.setItem(this.doc.uuid, encoded).then(function() {
                            console.log(`[debug] removed ${_this.doc.uuid}`);
                            _this.doc = new Document();
                            _this.showList = true;
                            _this.flashCheck();
                        }).catch(function(err) {
                            console.log("[error] problem removing: " + err);
                        });
                    }
                })
            },
            updateDoc: debounce(function() {
                if (this.showEdit) { // only update if in edit mode
                    // update the modified timestamp
                    this.doc.modified = moment.utc();

                    // update the hash
                    this.doc.hash = CryptoJS.SHA256(this.doc.uuid + this.doc.title + this.doc
                        .markdown).toString();


                    // update the URL
                    updateURL(this.doc.title, this.doc.uuid);

                    // update in the local storage
                    if (this.password != null) {
                        encoded = encode(JSON.stringify(this.doc), this.password);
                        localforage.setItem(this.doc.uuid, encoded);
                    };

                    // update in the server by sending an offer
                    console.log(`[debug] sending offer to server for '${this.doc.title}'`)
                    socketSend({
                        "type": "offer",
                        "user": this.username,
                        "hash": this.doc.hash,
                        "uuid": this.doc.uuid,
                    });
                    // update in the app
                    foundDoc = false;
                    for (i = 0; i < this.docs.length; i++) {
                        if (this.docs[i].uuid == this.doc.uuid) {
                            this.docs[i] = this.doc;
                            foundDoc = true
                            break
                        }
                    }
                    if (!foundDoc) {
                        console.log("adding new doc");
                        this.docs.push(this.doc);
                    }
                    this.flashCheck();
                }
            }, 400),
        },
        computed: {
            showListOrSearch: function() {
                return this.showList || this.showSearch;
            },
            showViewOrEdit: function() {
                return this.showView || this.showEdit;
            },
            sortedDocs: function() {
                return this.docs.sort(function(a, b) {
                    return new Date(b.modified) - new Date(a.modified);
                });
            },
            isCode: function() {
                if (this.doc.title == undefined) {
                    return false;
                }
                return this.doc.title.includes(".");
            }
        },
        watch: {
            username: function(val) {
                if (val == "") {
                    promptUser();
                }
            },
            showView: function(val) {
                if (val == true) {
                    this.showEdit = false;
                    // update the html (for viewer)
                    this.doc.rawHTML = (new showdown.Converter()).makeHtml(this.doc.markdown)
                }
            },
            showEdit: function(val) {
                if (val == true) {
                    this.showView = false;
                }
            },
            showList: function(val) {
                console.log(val);
                if (this.username == "" || this.password == "") {
                    promptUser();
                }
                if (val == true) {
                    console.log(`[debug] sorting ${app.docs.length} loaded docs`)
                    // TODO: set a flag to trigger load docs 
                    app.docs = app.docs.sort(function(a, b) {
                        return new Date(b.modified) - new Date(a.modified);
                    });

                    this.showEdit = false;
                    this.showView = false;
                    this.showSearch = false;
                    updateURL("/", "/");
                }
            },
            showSearch: function(val) {
                if (val) {
                    this.showEdit = false;
                    this.showView = false;
                    this.showList = false;
                }
            },
            showViewOrEdit: function(val) {
                if (val == true) {
                    this.showList = false;
                    this.showSearch = false;
                    updateURL(this.doc.title, this.doc.uuid);
                }
            },
        }
    })







    var CY = {};



    // Constructor function for Person objects
    // a = new Document();
    Document = function() {
        this.uuid = makeid();
        this.created = moment.utc();
        this.modified = moment.utc();
        this.title = "";
        this.markdown = "";
        this.hash = CryptoJS.SHA256(this.uuid + this.title + this.markdown).toString();
    }

    syncUp = function() {
        if (socket.readyState != 1) {
            return
        }
        localforage.keys().then(function(keys) {
            if (app.password != null) {
                keys.forEach(function(key) {
                    localforage.getItem(key).then(function(getValue) {
                        decoded = decode(getValue,
                            app.password);
                        if (decoded != null) {
                            try {
                                doc = JSON.parse(decoded);
                            } catch (e) {
                                console.log("[warn]: could not parse json")
                                return;
                            }

                            socketSend({
                                "type": "offer",
                                "user": app.username,
                                "hash": doc.hash,
                                "uuid": doc.uuid,
                            });
                        }
                    });
                });
            }
        }).catch(function(err) {
            // This code runs if there were any errors
            console.log(err);
        });
    }


    function socketSend(data) {
        if (socket == null) {
            return
        }
        if (socket.readyState != 1) {
            return
        }
        jsonData = JSON.stringify(data);
        console.log("[debug] uploading " + jsonData)
        socket.send(jsonData);
    }

    async function parseDoc(value) {
        decoded = decode(value, app.password);
        if (decoded != null) {
            try {
                doc = JSON.parse(decoded);
            } catch (e) {
                console.log("[warn]: could not parse json")
                return;
            }
            if (doc.title != "deleted") {
                console.log(`[debug] loaded '${doc.uuid}'`)
                app.docs.push(doc);
            } else {
                console.log(`[debug] skipping deleted '${doc.uuid}'`)
                // TODO: remove from localstorage if it is older than 10 days
            }
        }
    }

    function loadDocs() {
        console.log("[debug] loading docs")
        app.docs = [];

        localforage.iterate(function(value, key, iterationNumber) {
            parseDoc(value);
        }).then(function() {
            console.log('Iteration has completed');
        }).catch(function(err) {
            // This code runs if there were any errors
            console.log(err);
        });

    }

    function sortDocs() {
        console.log(`[debug] sorting ${app.docs.length} loaded docs`)
        app.docs = app.docs.sort(function(a, b) {
            return new Date(b.modified) - new Date(a.modified);
        });
    }

    function processSocketMessage(d) {
        console.log("[debug] received: " + JSON.stringify(d))
        if (!d.success) { // not a success
            console.log("error: " + d.message);
            return;
        }
        if (d.type == "request" && d.uuid != undefined) {
            // send the requested data to the server
            localforage.getItem(d.uuid).then(function(getValue) {
                socketSend({
                    "type": "update",
                    "user": app.username,
                    "uuid": d.uuid,
                    "hash": d.hash,
                    "data": getValue,
                });
            });
            return
        } else if (d.type == "hashes") {
            if (d.uuids == undefined) {
                console.log("[debug] no documents found");
                return;
            }
            // this will sync down
            // check to see if any hashes differ
            for (j = 0; j < d.uuids.length; j++) {
                // check if uuid exists
                var needs_update = true;
                for (i = 0; i < app.docs.length; i++) {
                    if (app.docs[i].uuid == d.uuids[j]) {
                        needs_update = !(app.docs[i].hash == d.hashes[j])
                        if (needs_update) {
                            console.log(`${app.docs[i].uuid}: ${d.hashes[j]} != ${app.docs[i].hash}`)
                        }
                        break
                    }
                }
                if (needs_update) {
                    console.log(`requesting ${d.uuids[j]} from server`)
                    socketSend({
                        "type": "request",
                        "user": app.username,
                        "uuid": d.uuids[j],
                    });
                }
            }
            // TODO: determine which ones to sync up
            // find all hashes that the client has and the server does not
            // the ones that need updating on the server will be checked
            // after the "update" comes form the server
        } else if (d.type == "update") {
            // received an update for the data in the app
            decoded = decode(d.data, app.password);
            if (decoded != null) {
                try {
                    doc = JSON.parse(decoded)
                } catch (err) {
                    console.log(err)
                    return;
                }

                if (doc != null) {
                    doci = -1;
                    for (i = 0; i < app.docs.length; i++) {
                        if (app.docs[i].uuid == doc.uuid) {
                            doci = i;
                            break
                        }
                    }
                    if (doci == -1) {
                        // this is a new doc, push it
                        console.log(`incoming '${doc.uuid}' is new`)
                        encoded = encode(JSON.stringify(doc), app.password);
                        localforage.setItem(doc.uuid, encoded);
                    } else {
                        // check to see if the timestamp is newer or older
                        // if newer, re-encode and update
                        incoming_doc_is_newer = doc.modified > app.docs[i].modified;
                        if (incoming_doc_is_newer) {
                            // re-encode and save and update the app
                            console.log(`incoming '${doc.uuid}' is newer`)
                            encoded = encode(JSON.stringify(doc), app.password);
                            localforage.setItem(doc.uuid, encoded);
                            app.docs[doci] = doc;
                            if (app.doc.uuid == doc.uuid) {
                                app.doc = doc;
                            }
                        } else {
                            // update the server with the current version
                            console.log(`incoming '${doc.uuid}' is older, updating server`)
                            encoded = encode(JSON.stringify(app.docs[doci]), app.password);
                            socketSend({
                                "type": "update",
                                "user": app.username,
                                "uuid": app.docs[doci].uuid,
                                "hash": app.docs[doci].hash,
                                "data": encoded,
                            });
                        }
                    }
                }
            }
        } else if (d.type == "message") {
            console.log("[info] message: " + d.message);
        } else {
            console.log(`[warn] unknown type: ${d.type}`)
        }
    }







    // encryption
    const keySize = 128;
    const ivSize = 64;
    const iterations = 10;

    // http://www.adonespitogo.com/articles/encrypting-data-with-cryptojs-aes/
    function encode(msgString, pass) {
        msg = CryptoJS.enc.Utf16.parse(LZString.compressToUTF16(msgString))
        var salt = CryptoJS.lib.WordArray.random(128 / 8);

        var key = CryptoJS.PBKDF2(pass, salt, {
            keySize: keySize / 32,
            iterations: iterations
        });

        var iv = CryptoJS.lib.WordArray.random(128 / 8);

        var encrypted = CryptoJS.AES.encrypt(msg, key, {
            iv: iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC

        });

        // salt, iv will be hex 32 in length
        // append them to the ciphertext for use  in decryption
        var transitmessage = salt.toString() + iv.toString() + encrypted.toString();
        return transitmessage;
    }

    function decode(transitmessage, pass) {
        if (transitmessage == null) {
            console.log("got null transmit message")
            return null;
        }
        var salt = CryptoJS.enc.Hex.parse(transitmessage.substr(0, 32));
        var iv = CryptoJS.enc.Hex.parse(transitmessage.substr(32, 32))
        var encrypted = transitmessage.substring(64);

        var key = CryptoJS.PBKDF2(pass, salt, {
            keySize: keySize / 32,
            iterations: iterations
        });

        var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
            iv: iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC

        })
        return LZString.decompressFromUTF16(decrypted.toString(CryptoJS.enc.Utf16));
    }


    function promptUser() {
        app.username = Cookies.get('app.username');
        app.password = decode(Cookies.get('app.password'), app.username);
        if (app.username == undefined || app.username == "undefined" || app.username == "") {
            Swal.fire({
                title: 'Enter your user name',
                input: 'text',
                inputPlaceholder: 'Enter your user name',
                inputAttributes: {
                    autocapitalize: 'off',
                    autocorrect: 'off',
                },
                inputValidator: (value) => {
                    if (!value) {
                        return 'You need to write something!'
                    }
                }
            }).then(result => {
                app.username = result.value;
                Cookies.set('app.username', app.username);
                app.password = decode(Cookies.get('app.password'), app.username);
                if (app.password == undefined || app.password == null) {
                    promptPassword();
                }
            })
        } else if (app.password == undefined || app.password == null || app.password == "undefined" || app.password == "") {
            promptPassword();
        } else {
            startup();
        }
    }


    function promptPassword() {
        Swal.fire({
            title: 'Enter your password',
            input: 'password',
            inputPlaceholder: 'Enter your password',
            inputAttributes: {
                autocapitalize: 'off',
                autocorrect: 'off'
            },
            inputValidator: (value) => {
                if (!value) {
                    return 'You need to write something!'
                }
            }
        }).then(result => {
            app.password = result.value;
            Cookies.set('app.password', encode(app.password, app.username));
            startup();
        });
    }


    function startup() {
        loadDocs();
        app.doc = new Document();
        var loadedDoc = false;
        if (window.location.pathname != "/") {
            titleToFind = window.location.pathname.substring(1, window.location.pathname.length);
            localforage.keys().then(function(keys) {
                if (app.password != null) {
                    keys.forEach(function(key) {
                        localforage.getItem(key).then(function(getValue) {
                            decoded = decode(getValue,
                                app.password);
                            if (decoded != null) {
                                try {
                                    doc = JSON.parse(decoded);
                                } catch (e) {
                                    console.log("[warn]: could not parse json")
                                    return;
                                }
                                if (slugify(doc.title) == slugify(titleToFind) || doc
                                    .uuid == titleToFind) {
                                    app.doc = doc;
                                    console.log(app.doc);
                                    app.showView = true;
                                    loadedDoc = true;
                                }
                            }
                        });
                    });
                }
            }).catch(function(err) {
                // This code runs if there were any errors
                console.log(err);
            });
        }
        if (loadedDoc == false) {
            app.showList = true;
        }
        socketCloseListener();
    }


    function getSnippet(text, word, locations) {
        const locationLimit = 60;

        function trimLeftWords(text) {
            text = text.split(/[ ]+/).join(" ");
            for (var i = 0; i < text.length - 1; i++) {
                if (text[i] == " ") {
                    text = text.substring(i + 1, text.length);
                    break;
                }
            }
            return "..." + text;
        }

        function trimRightWords(text) {
            text = text.split(/[ ]+/).join(" ");
            for (var i = text.length; i > 1; i--) {
                if (text[i] == " ") {
                    text = text.substring(0, i);
                    break;
                }
            }
            return text + "...";
        }

        function formatSnippet(text, currentSection, word) {
            var re = new RegExp(word, 'g');
            snippet = text.substring(currentSection[0], currentSection[1]);
            if (currentSection[0] > 0) {
                snippet = trimLeftWords(snippet);
            }
            if (currentSection[1] < text.length) {
                snippet = trimRightWords(snippet);
            }
            return snippet.replace(re, "<mark>" + word + "</mark>");
        }

        var snippets = [];
        var currentSection = [0, locationLimit];
        for (var i = 0; i < locations.length; i++) {
            if (locations[i] > currentSection[1] + locationLimit) {
                snippets.push(formatSnippet(text, currentSection, word));
                currentSection[0] = locations[i] - locationLimit;
            }
            currentSection[1] = locations[i] + locationLimit;
        }
        snippets.push(formatSnippet(text, currentSection, word));

        return snippets.join(" ");
    }




    window.addEventListener('popstate', (event) => {
        console.log("[debug] location: " + document.location + ", state: " + JSON.stringify(event.state));
        app.showView = event.state.showView;
        app.showEdit = event.state.showEdit;
        app.showSearch = event.state.showSearch;
        app.showList = event.state.showList;
    });
    document.getElementById('import').onclick = function() {
        var files = document.getElementById('selectFiles').files;
        console.log(files);
        if (files.length <= 0) {

            return false;
        }
        var fr = new FileReader();
        fr.onload = function(e) {
            console.log(e);
            var result = JSON.parse(e.target.result);
            console.log(result);
            result.forEach(function(doc) {
                console.log(doc.id);
                console.log(doc.data);
                newdoc = { "uuid": doc.id, "title": doc.slug, "created": doc.created, "modified": doc.modified, "markdown": doc.data, };
                console.log(newdoc);
                app.docs.push(newdoc);
                sortDocs();
                encoded = encode(JSON.stringify(newdoc), app.password);
                localforage.setItem(newdoc.uuid, encoded);
            })
        }
        fr.readAsText(files.item(0));
    };


    window.onload = function() {
        promptUser();

    }

s=`Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Egestas tellus rutrum tellus pellentesque. Vitae sapien pellentesque habitant morbi. Sit amet nisl purus in mollis nunc sed. Aenean et tortor at risus. Massa id neque aliquam vestibulum. Sed risus ultricies tristique nulla aliquet. Lacus vel facilisis volutpat est. Est ullamcorper eget nulla facilisi etiam dignissim diam quis enim. Curabitur gravida arcu ac tortor dignissim convallis aenean. Posuere ac ut consequat semper viverra nam. Nulla aliquet enim tortor at. Tempor id eu nisl nunc mi ipsum faucibus vitae. Arcu bibendum at varius vel. Aliquam sem et tortor consequat id porta. Felis bibendum ut tristique et. Proin nibh nisl condimentum id venenatis a condimentum vitae. Purus sit amet luctus venenatis. Tincidunt tortor aliquam nulla facilisi cras fermentum odio eu feugiat. Erat pellentesque adipiscing commodo elit at imperdiet dui accumsan.

Est ullamcorper eget nulla facilisi. Molestie at elementum eu facilisis sed odio morbi quis commodo. Pellentesque nec nam aliquam sem et. Diam vulputate ut pharetra sit amet aliquam id. Magna fermentum iaculis eu non diam phasellus vestibulum lorem. Vitae tortor condimentum lacinia quis vel eros donec ac odio. Tempus egestas sed sed risus. A iaculis at erat pellentesque adipiscing commodo elit at imperdiet. Faucibus ornare suspendisse sed nisi lacus sed viverra. Enim neque volutpat ac tincidunt vitae. Massa vitae tortor condimentum lacinia. Lacus viverra vitae congue eu consequat.

Faucibus turpis in eu mi. Augue ut lectus arcu bibendum at varius. Ultrices sagittis orci a scelerisque purus semper eget. Morbi non arcu risus quis varius. Id porta nibh venenatis cras sed felis eget velit aliquet. Imperdiet nulla malesuada pellentesque elit eget gravida. Malesuada fames ac turpis egestas. Lobortis elementum nibh tellus molestie nunc. Condimentum lacinia quis vel eros donec ac odio. Egestas sed tempus urna et pharetra pharetra massa massa ultricies. Lectus magna fringilla urna porttitor rhoncus dolor purus. Sed elementum tempus egestas sed sed risus pretium quam. Ut sem nulla pharetra diam sit amet nisl suscipit adipiscing. Ultrices in iaculis nunc sed augue. Nec sagittis aliquam malesuada bibendum arcu vitae elementum curabitur vitae. Leo urna molestie at elementum eu facilisis sed odio morbi. Enim nulla aliquet porttitor lacus luctus accumsan tortor. Cras fermentum odio eu feugiat pretium. Volutpat commodo sed egestas egestas fringilla phasellus faucibus.

Ligula ullamcorper malesuada proin libero nunc consequat interdum varius. Egestas sed tempus urna et pharetra pharetra. Libero id faucibus nisl tincidunt. Ultrices gravida dictum fusce ut. Tellus integer feugiat scelerisque varius. Maecenas accumsan lacus vel facilisis volutpat est. Malesuada proin libero nunc consequat interdum varius. Lectus nulla at volutpat diam ut. Curabitur vitae nunc sed velit dignissim sodales ut. Nullam eget felis eget nunc lobortis mattis aliquam faucibus purus. Mattis ullamcorper velit sed ullamcorper. Neque egestas congue quisque egestas. Sed felis eget velit aliquet sagittis id consectetur purus. Molestie at elementum eu facilisis sed odio morbi. Morbi tincidunt augue interdum velit euismod. Vel facilisis volutpat est velit. Lobortis elementum nibh tellus molestie nunc non blandit massa enim. Vel turpis nunc eget lorem dolor sed viverra ipsum.

Mi bibendum neque egestas congue quisque egestas. Auctor urna nunc id cursus metus aliquam. A iaculis at erat pellentesque adipiscing commodo elit at. Dignissim diam quis enim lobortis scelerisque fermentum dui. Enim ut sem viverra aliquet eget. Pellentesque elit ullamcorper dignissim cras tincidunt. Malesuada bibendum arcu vitae elementum curabitur vitae nunc. Augue interdum velit euismod in pellentesque massa placerat duis ultricies. Pellentesque elit eget gravida cum sociis natoque. Sit amet aliquam id diam maecenas ultricies mi. Tellus molestie nunc non blandit massa. Leo vel fringilla est ullamcorper eget. In fermentum posuere urna nec tincidunt praesent. A diam sollicitudin tempor id eu. Mi proin sed libero enim sed. Tempor id eu nisl nunc mi ipsum faucibus vitae. Adipiscing bibendum est ultricies integer quis auctor elit.`

	    var t0 = performance.now();
	    for (i=0;i<10;i++) {
		encode(s,"somepassword");
	    }
var t1 = performance.now();
console.log("Call to doSomething took " + (t1 - t0)/10 + " milliseconds.")

var encoded = encode(s,"somepassword");
	    var t0 = performance.now();
	    for (i=0;i<10;i++) {
		decode(encoded,"somepassword");
	    }
var t1 = performance.now();
console.log("Call to doSomething took " + (t1 - t0)/10 + " milliseconds.")
    </script>
</body>

</html>
