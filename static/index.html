<!doctype html>
<html lang=en-US>

<head>
    <meta charset='utf-8'>
    <title>The Air Horner</title>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='description' content='An Air horn. Probably the best air horn web app there is.'>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='canonical' href='https://airhorner.com/'>
    <link rel='manifest' href='/static/manifest.json'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <meta name='application-name' content='Air Horner'>
    <meta name='apple-mobile-web-app-status-bar-style' content='black'>
    <meta name='apple-mobile-web-app-title' content='Air Horner'>
    <link rel='icon' sizes='192x192' href='/static/images/touch/Airhorner_192.png'>
    <link rel='apple-touch-icon' href='/static/images/touch/Airhorner_192.png'>
    <meta name='msapplication-TileImage' content='/static/images/touch/Airhorner_144.png'>
    <meta name='msapplication-TileColor' content='#2196F3'>
    <meta name='theme-color' content='#2196F3'>
    <meta property='og:title' content='Air Horn'>
    <meta property='og:type' content='website'>
    <meta property='og:image' content='https://airhorner.com/images/touch/Airhorner_192.png'>
    <meta property='og:url' content='https://airhorner.com/'>
    <meta property='og:description' content='The best and easiest Air Horn web app there is. No install just use it right away in your browser!'>
    <meta name='twitter:card' content='summary'>
    <meta name='twitter:url' content='https://airhorner.com/'>
    <meta name='twitter:title' content='Air Horn'>
    <meta name='twitter:description' content='The best and easiest Air Horn web app there is. No install just use it right away in your browser!'>
    <meta name='twitter:image' content='https://airhorner.com/images/touch/Airhorner_192.png'>
    <meta name='twitter:creator' content='@paul_kinlan'>
    <link rel='stylesheet' href='/static/css/style.css'>
    <!-- <script src='/static/js/pwacompat.min.js' async></script> -->
</head>

<body>
    <main id="app">
        <div class="topbar" v-cloak>
            <span class="fl fonty">
                <a id='listlink' v-on:click="showList = true">Home</a>&nbsp;
                <a id='newlink' v-on:click="makeNew">New</a>&nbsp;
                <a id='viewlink' v-on:click="showView = true" v-show="showEdit">View</a>
                <a id='editlink' v-on:click="showEdit = true" v-show="showView">Edit</a>
            </span>
            <span class="fr fonty" v-show="showViewOrEdit">
            </span>
        </div>
        <div class="list" v-show="showList" v-cloak>
            <div v-for="doc in sortedDocs">
                <div v-bind:id="doc.uuid" v-on:click="select($event)"><span class="link" v-if="doc.title">{{doc.title}}</span><span v-else>{{doc.uuid}}</span></div>
                <div>{{doc.created}}</div>
            </div>
        </div>
        <div class="fonty" v-show="showView" v-cloak>
            <h1 v-if="doc.title">{{doc.title}}</h1>
            <h1 v-else>{{doc.uuid}}</h1>
            <!-- TODO: if . in title, show raw pre-formated text -->
            <div v-html="doc.rawHTML"></div>
        </div>
        <input id="edittitle" v-show="showEdit" placeholder="Title" v-model="doc.title" v-on:keyup="updateDoc" v-cloak>
        <textarea class="writing" v-show="showEdit" id="editable" rows=110 placeholder="Click here and start writing" autofocus v-on:keyup="updateDoc" v-model="doc.markdown" v-cloak>
            {{doc.markdown}}
                        <!-- TODO: if . in title, show raw pre-formated text -->

        </textarea>
    </main>
    <script src="/static/js/vue.js"></script>
    <script src="/static/js/lz-string.js"></script>
    <script src="/static/js/pako.min.js"></script>
    <script src="/static/js/crypto-js.min.js"></script>
    <script src="/static/js/enc-utf16.min.js"></script>
    <script src="/static/js/lunr.min.js"></script>
    <script src="/static/js/localforage.js"></script>
    <script src="/static/js/showdown.min.js"></script>
    <!-- <script>
        /* code for the service worker */
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/static/sw.js', {
                    scope: '/'
                })
                .then(function (registration) {
                    console.log('Service Worker Registered');
                });
            navigator.serviceWorker.ready.then(function (registration) {
                console.log('Service Worker Ready');
            });
        }
    </script> -->
    <script>
    /* init */
    // initialize local storage
    localforage.setDriver([
        localforage.INDEXEDDB,
        localforage.WEBSQL,
        localforage.LOCALSTORAGE
    ])

    /* 
    globals */
    var globalPassword = "zack";
    var globalUser = "z"
    var socket; // websocket
    var hasConnected = false;


    /* generic functions */
    // debounce function
    debounce = function(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this,
                args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) {
                    func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait || 200);
            if (callNow) {
                func.apply(context, args);
            }
        };
    };

    // replace all
    String.prototype.replaceAll = function(search, replacement) {
        var target = this;
        return target.replace(new RegExp(search, 'g'), replacement);
    };

    // create UUID
    function create_UUID() {
        var dt = new Date().getTime();
        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = (dt + Math.random() * 16) % 16 | 0;
            dt = Math.floor(dt / 16);
            return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
        return uuid;
    }


    // slugify the current text
    function slugify(text) {
        var lines = text.split('\n');
        for (var i = 0; i < lines.length; i++) {
            var slug = lines[i].toString().toLowerCase()
                .replace(/\s+/g, '-') // Replace spaces with -
                .replace(/[^\w\-]+/g, '') // Remove all non-word chars
                .replace(/\-\-+/g, '-') // Replace multiple - with single -
                .replace(/^-+/, '') // Trim - from start of text
                .replace(/-+$/, ''); // Trim - from end of text
            if (slug.length > 1) {
                return slug;
            }
        }
        return "";
    }

    // update the history
    function updateURL(url1, url2) {
        var newwindowname = slugify(url1);
        if (newwindowname == "") {
            newwindowname = url2;
        }
        // console.log(newwindowname);
        if (newwindowname != undefined && newwindowname.length > 0 && "/" + newwindowname !=
            window.location
            .pathname && newwindowname != window.location.pathname) {
            history.replaceState({}, newwindowname, newwindowname);
            document.title = newwindowname;
        }
    }

    /* websockets */
    const socketMessageListener = (event) => {
        var data = JSON.parse(event.data);
        processSocketMessage(data);
    };
    const socketOpenListener = (event) => {
        console.log('Connected');
        if (!hasConnected) {
            hasConnected = true;
            // request hashes
            socket.send(JSON.stringify({
                "type": "hashes",
                "user": globalUser,
            }));
        }
        // CY.updateServer();
    };
    const socketCloseListener = (event) => {
        if (socket) {
            console.log('Disconnected.');
        }
        var url = window.origin.replace("http", "ws") + '/ws';
        socket = new WebSocket(url);
        socket.addEventListener('open', socketOpenListener);
        socket.addEventListener('message', socketMessageListener);
        socket.addEventListener('close', socketCloseListener);
    };



    /* vue apps */
    var app = new Vue({
        el: '#app',
        data: {
            docs: [],
            doc: {},
            sortedItems: [],
            showView: false,
            showEdit: false,
            showList: false,
        },
        methods: {
            makeNew: function(e) {
                this.doc = new Document();
                this.showEdit = true;
            },
            select: function(event) {
                doc_uuid = event.currentTarget.id;
                console.log(`clicked ${doc_uuid}`)
                for (i = 0; i < this.docs.length; i++) {
                    if (this.docs[i].uuid == doc_uuid) {
                        this.doc = this.docs[i];
                        this.showView = true;
                        break
                    }
                }
            },
            updateDoc: debounce(function() {
                console.log(this.doc.title);
                if (this.showEdit) { // only update if in edit mode
                    // update the modified timestamp
                    this.doc.modified = new Date();

                    // update the html (for viewer)
                    this.doc.rawHTML = (new showdown.Converter()).makeHtml(this.doc.markdown)

                    // update the hash
                    this.doc.hash = CryptoJS.SHA256(this.doc.uuid + this.doc.title + this.doc.markdown).toString();


                    // update the URL
                    updateURL(this.doc.title, this.doc.uuid);

                    // update in the local storage
                    if (globalPassword != null && socket.readyState == 1) {
                        encoded = encode(JSON.stringify(this.doc), globalPassword);
                        localforage.setItem(this.doc.uuid, encoded, function() {
                            console.log(
                                `uploaded ${encoded.length} bytes for '${this.doc.title}' (${this.doc.uuid})`);
                        });
                    };

                    // update in the server by sending an offer
                    if (socket != null) {
                        console.log(`sending offer to server for ${this.doc.uuid}`)
                        if (socket.readyState == 1) {
                            socket.send(JSON.stringify({
                                "type": "offer",
                                "user": globalUser,
                                "hash": this.doc.hash,
                                "uuid": this.doc.uuid,
                            }));
                        }
                    }


                    // update in the app
                    foundDoc = false;
                    for (i = 0; i < this.docs.length; i++) {
                        if (this.docs[i].uuid == this.doc.uuid) {
                            this.docs[i] = this.doc;
                            foundDoc = true
                            break
                        }
                    }
                    if (!foundDoc) {
                        console.log("adding new doc");
                        this.docs.push(this.doc);
                        this.docs = this.docs.sort(function(a, b) {
                            return new Date(b.modified) - new Date(a.modified);
                        });
                    }
                }
            }, 200),
        },
        computed: {
            showViewOrEdit: function() {
                return this.showView || this.showEdit;
            },
            sortedDocs: function() {
                return this.docs.sort(function(a, b) {
                    return new Date(b.modified) - new Date(a.modified);
                });
            }
        },
        watch: {
            showView: function(val) {
                if (val == true) {
                    this.showEdit = false;
                }
            },
            showEdit: function(val) {
                if (val == true) {
                    this.showView = false;
                }
            },
            showList: function(val) {
                if (val == true) {
                    this.showEdit = false;
                    this.showView = false;
                    updateURL("/", "/");
                }
            },
            showViewOrEdit: function(val) {
                if (val == true) {
                    this.showList = false;
                    updateURL(this.doc.title, this.doc.uuid);
                }
            },
        }
    })







    var CY = {};



    // Constructor function for Person objects
    // a = new Document();
    Document = function() {
        this.uuid = create_UUID();
        this.created = new Date();
        this.modified = new Date();
        this.title = "";
        this.markdown = "";
        this.hash = CryptoJS.SHA256(this.uuid + this.title + this.markdown).toString();
    }

    loadDocs = function() {
        app.docs = [];
        localforage.keys().then(function(keys) {
            if (globalPassword != null) {
                keys.forEach(function(key) {
                    localforage.getItem(key).then(function(getValue) {
                        decoded = decode(getValue,
                            globalPassword);
                        if (decoded != null) {
                            doc = JSON.parse(decoded);
                            console.log("loaded: " + doc.uuid + (doc != null));
                            app.docs.push(doc);
                        }
                    });
                });
                app.docs = app.docs.sort(function(a, b) {
                    return new Date(b.modified) - new Date(a.modified);
                });
            }
        }).catch(function(err) {
            // This code runs if there were any errors
            console.log(err);
        });
    }

    processSocketMessage = function(d) {
        console.log("processing " + JSON.stringify(d))
        if (!d.success) { // not a success
            console.log("error: " + d.message);
            return;
        }
        if (d.type == "request" && d.uuid != undefined) {
            // send the requested data to the server
            localforage.getItem(d.uuid).then(function(getValue) {
                socket.send(JSON.stringify({
                    "type": "update",
                    "user": globalUser,
                    "uuid": d.uuid,
                    "hash": d.hash,
                    "data": getValue,
                }));
            });
            return
        } else if (d.type == "hashes" && d.uuids.length > 0) {
            // check to see if any hashes differ
            for (j = 0; j < d.uuids.length; j++) {
                // check if uuid exists
                var needs_update = true;
                for (i = 0; i < app.docs.length; i++) {
                    if (app.docs[i].uuid == d.uuids[j]) {
                        needs_update = !(app.docs[i].hash == d.hashes[j])
                        break
                    }
                }
                if (needs_update) {
                    console.log(`requesting ${d.uuids[j]} from server`)
                    socket.send(JSON.stringify({
                        "type": "request",
                        "user": globalUser,
                        "uuid": d.uuids[j],
                    }));
                }
            }
        } else if (d.type == "update") {
            // received an update for the data in the app
            decoded = decode(d.data, globalPassword);
            if (decoded != null) {
                doc = JSON.parse(decoded)
                if (doc != null) {
                    // TODO: check to see which version is newer
                    // if the client version is newer, upload to the server
                    // if the server version is newer

                    doci = -1;
                    for (i = 0; i < app.docs.length; i++) {
                        if (app.docs[i].uuid == doc.uuid) {
                            doci = i;
                            break
                        }
                    }
                    if (doci == -1) {
                        // this is a new doc, push it
                        app.docs.push(doc);
                    } else {
                        // check to see if the timestamp is newer or older
                        // if newer, re-encode and update
                        incoming_doc_is_newer = doc.modified > app.docs[i].modified;
                        if (incoming_doc_is_newer) {
                            console.log("incoming ${doc.title} is newer")
                            // re-encode and save and update the app
                            encoded = encode(JSON.stringify(doc), globalPassword);
                            localforage.setItem(doc.uuid, encoded, function() {
                                console.log(
                                    `recieved ${encoded.length} bytes for '${doc.title}' (${doc.uuid})`);
                            });
                            app.docs[doci] = doc;
                        } else {
                            console.log("incoming ${doc.title} is older, updating server")
                            // update the server with the current version
                            encoded = encode(JSON.stringify(app.docs[doci]), globalPassword);
                            socket.send(JSON.stringify({
                                "type": "update",
                                "user": globalUser,
                                "uuid": app.docs[doci].uuid,
                                "hash": app.docs[doci].hash,
                                "data": encoded,
                            }));
                        }
                    }
                }
            }
        } else if (d.type == "message") {
            console.log("message: " + d.message);
        } else {
            console.log(`unknown type: ${d.type}`)
        }
    }

    // TODO: indexing

    // var documents = [{
    //     "name": "Lunr",
    //     "text": "Like Solr, but much smaller, and not as bright."
    // }, {
    //     "name": "React",
    //     "text": "A JavaScript library for building user interfaces."
    // }, {
    //     "name": "Lodash",
    //     "text": "A modern JavaScript utility library delivering modularity, performance & extras."
    // }]
    // var idx = lunr(function () {
    //     this.ref('name')
    //     this.field('text')

    //     documents.forEach(function (doc) {
    //         this.add(doc)
    //     }, this)
    // })

    // idx.search("bright")





    var keySize = 256;
    var ivSize = 128;
    var iterations = 100;

    // http://www.adonespitogo.com/articles/encrypting-data-with-cryptojs-aes/

    function encode(msgString, pass) {
        msg = CryptoJS.enc.Utf16.parse(LZString.compressToUTF16(msgString))
        var salt = CryptoJS.lib.WordArray.random(128 / 8);

        var key = CryptoJS.PBKDF2(pass, salt, {
            keySize: keySize / 32,
            iterations: iterations
        });

        var iv = CryptoJS.lib.WordArray.random(128 / 8);

        var encrypted = CryptoJS.AES.encrypt(msg, key, {
            iv: iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC

        });

        // salt, iv will be hex 32 in length
        // append them to the ciphertext for use  in decryption
        var transitmessage = salt.toString() + iv.toString() + encrypted.toString();
        return transitmessage;
    }

    function decode(transitmessage, pass) {
        if (transitmessage == null) {
            console.log("got null transmit message")
            return null;
        }
        var salt = CryptoJS.enc.Hex.parse(transitmessage.substr(0, 32));
        var iv = CryptoJS.enc.Hex.parse(transitmessage.substr(32, 32))
        var encrypted = transitmessage.substring(64);

        var key = CryptoJS.PBKDF2(pass, salt, {
            keySize: keySize / 32,
            iterations: iterations
        });

        var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
            iv: iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC

        })
        return LZString.decompressFromUTF16(decrypted.toString(CryptoJS.enc.Utf16));
    }



    window.onload = function() {
        // TODO: check password
        // globalPassword = prompt("Choose a passphrase for encryption:");
        app.doc = new Document();
        loadDocs();
        var loadedDoc = false;
        if (window.location.pathname != "/") {
            titleToFind = window.location.pathname.substring(1, window.location.pathname.length);
            localforage.keys().then(function(keys) {
                if (globalPassword != null) {
                    keys.forEach(function(key) {
                        localforage.getItem(key).then(function(getValue) {
                            decoded = decode(getValue,
                                globalPassword);
                            if (decoded != null) {
                                doc = JSON.parse(decoded)
                                if (slugify(doc.title) == slugify(titleToFind) || doc.uuid == titleToFind) {
                                    app.doc = doc;
                                    console.log(app.doc);
                                    app.showView = true;
                                    loadedDoc = true;
                                }
                            }
                        });
                    });
                }
            }).catch(function(err) {
                // This code runs if there were any errors
                console.log(err);
            });
        }
        if (loadedDoc == false) {
            app.showList = true;
        }
        socketCloseListener();
    }
    </script>
</body>

</html>